#!/usr/bin/ruby
# Run as follows
# cd /production/sites/sislsrs ; rails runner app/scripts/test_lsrs5_batch_cron.rb

# create color palette for output text
require '/home/peter/bin/lib/colorize.rb'

# set up environment
#require '/production/sites/sislsrs/app/models/other/batch.rb'
#Batch.load_some_libraries()
#equire 'redis'
redis = Redis.new
@batchDir = "/production/sites/sislsrs/public/batch/"
Dir.chdir(@batchDir + "pending/")

# get control file
nextJob = "20170529t144757r2614_control.yml"         # TODO: remove hard coding

@controlPathname = @batchDir + "pending/" + nextJob
@control = YAML.load_file(@controlPathname)

# parse contents of control file
@detailsRootURL = @control['DetailsRootURL']
outputXmlFilename = @control['OutputXmlFilename']
outputCsvFilename = @control['OutputCsvFilename']
outputDbfFilename = @control['OutputDbfFilename']
outputHtmlFilename = @control['OutputHtmlFilename']
outputDbfSummaryFilename = @control['OutputDbfSummaryFilename']
@statusFilename = @control['StatusFilename']
@statusURL = @control['StatusURL']
@outputURL = @control['OutputURL']
@frameworkName = @control['FrameworkName']
@cmpTable = @control['ComponentTable']
@fromPoly = @control['FromPoly']
@toPoly = @control['ToPoly']
@crop = @control['Crop']
@management = @control['Management']
@climateName = @control['ClimateTable']  # TODO: change from MySQL table row to Redis key name

puts "@frameworkName = #{@frameworkName}".yellow
puts "@climateName = #{@climateName}".yellow

# Get array of polygon identifiers from the text file that was generated by the lsrsbatch_controller
@slArray = File.new(@control['PolygonsFilename']).readlines.map {|line| line.chomp}

# set some names
@climateSourcePathname = "/production/data/climate/polygons/#{@climateName}.txt"
@normalsDumpPathname = @climateSourcePathname + "2normals.redisdump"
@indicesDumpPathname = @climateSourcePathname + "3indices.redisdump"
@normalsKey = "#{@frameworkName}:#{@climateName}:normals"
@indicesKey = "#{@frameworkName}/#{@climateName}:indices"

puts @climateSourcePathname.red
puts @normalsDumpPathname .red
# check to see if climate data has been processed into indices
if not File.exist?(@climateSourcePathname) then puts "ERROR: Climate data file doesn't exist"; exit end
if not File.exist?(@normalsDumpPathname) then puts "NOTE: Climate data redisdump file doesn't exist" end
if not File.exist?(@indicesDumpPathname) then puts "NOTE: Climate indices redisdump file doesn't exist" end

# load or update climate data into Redis if necessary

# normals dump may be outdated (if source data was edited or updated on disk) or was never created
if File.exist?(@normalsDumpPathname) and File.mtime(@normalsDumpPathname) > File.mtime(@climateSourcePathname) then 
	# normals dump file is up to date
	if redis.expire(@normalsKey, 20000000) then
		puts "ttl for normals key was reset"
	else # key has expired, so reload from dump file
		redis.restore(@normalsKey,20000000,File.read(@normalsDumpPathname))
		puts "normals key was reloaded"
	end
else
	# normals redis key and redisdump as well as metadata file need to be created/updated
	puts "Refreshing redisdump of normals data"
	#Climate_load.monthlies(@climateSourcePathname, @normalsKey, @normalsDumpPathname)
	Climate_load.monthlies(@climateSourcePathname, @normalsKey)
	redis.expire(@normalsKey, 20000000)
end

# indices may be outdated or were never created
if File.exist?(@indicesDumpPathname) and File.mtime(@indicesDumpPathname) > File.mtime(@normalsDumpPathname) then
	# indices dump file is up to date
	if redis.expire(@indicesKey, 20000000) then
		puts "ttl for indices key was reset"
	else # key has expired, so reload from dump file
		redis.restore(@indicesKey,20000000,File.read(@indicesDumpPathname))
		puts "indices key was reloaded"
	end
else 
	# indices dump is outdated, so both redis key and redisdump need to be created/updated
	puts "Refreshing redisdump of indices"
	Climate_calc.monthlies(@normalsKey, @indicesKey, @indicesDumpPathname, redis)
	redis.expire(@indicesKey, 20000000)
end

# At this point redis has the latest climate data loaded, so calculate the LSRS ratings

@batch = AccessorsPolygonbatch.new

@batch.frameworkName = @control['FrameworkName']
@batch.cmpTableName = @control['ComponentTable']
@batch.fromPoly = @control['FromPoly'] # needed???
@batch.toPoly = @control['ToPoly'] # needed???
@batch.region = @control['Region'] # needed???
# Get array of polygon identifiers from the text file that was generated by the lsrsbatch_controller
@batch.polygonsHash = Hash[File.new(@control['PolygonsFilename']).readlines.map {|line| line.chomp}.sort.uniq.zip]
@batch.crop = @control['Crop']
@batch.cropHash.store("CROP", @control['Crop']) # needed???
@batch.climateTableName = @control['ClimateTable']
@batch.climateIndicesKey = @control['ClimateTable'] + ":indices"
@batch.climateMetadata = JSON.parse(File.read("/production/data/climate/polygons/#{@control['ClimateTable']}.txt1metadata.json"), object_class: OpenStruct)
@batch.management = @control['Management']

puts @control['OutputHtmlFilename']
puts @batch.climateMetadata

puts "Debugging from here".red


# Create the HTML file
outputHtmlFile = File.open(@control['OutputHtmlFilename'], 'w') 
outputHtmlFile.puts '<html>'
outputHtmlFile.puts '<head>'
outputHtmlFile.puts '<title>LSRS results</title>'
outputHtmlFile.puts '</head>'
outputHtmlFile.puts '<body>'
outputHtmlFile.puts '<h2>Land Suitability Rating Information</h2>'
outputHtmlFile.puts '<table class="intro">'
outputHtmlFile.puts '<tr><td class="subheader">Database:</td><td class="Abbr">' + LsrsFramework.where(:WarehouseName => @frameworkName).first.Title_en + '</td></tr>'
outputHtmlFile.puts '<tr><td class="subheader">Climate:</td><td class="Abbr">' + @batch.climateMetadata.Title + '</td></tr>'
outputHtmlFile.puts '<tr><td class="subheader">Crop:</td><td class="Abbr">' + @crop + '</td></tr>'
outputHtmlFile.puts '<tr><td class="subheader">Management:</td><td class="Abbr">' + @management + '</td></tr>'
outputHtmlFile.puts '</table>'
outputHtmlFile.puts '<br/>'
outputHtmlFile.puts '<table>'

# Create the CSV file
outputCsvFile = File.open(@control['OutputCsvFilename'], 'w')
outputCsvFile.puts "POLY_ID,CMP_ID,POLY_RATING,CMP,PERCENT,CMP_CLASS,CLIMATE_POINTS,CLIMATE_CLASS,PROVINCE,SOIL_CODE,SOIL_NAME,SOIL_POINTS,SOIL_CLASS,LANDSCAPE_POINTS,LANDSCAPE_CLASS"

# populate the HTML and CSV files
# don't call Polygonbatch.calc_ratings(@batch) here because of the need to dump out different content for HTML vs CSV
params2 = {"FrameworkName"=>@batch.frameworkName, "Climate"=>@batch.climateTableName, "Crop"=>@batch.crop, "Management"=>@batch.management}
for poly in @batch.polygonsHash.keys do
	params2["PolyId"] = poly
	@rating = AccessorsRating.new
	Validate.polygon(params2, @rating)
	Polygon.get_data(@rating.polygon, @rating.climateData, @rating.errors) if @rating.errors == []
	Polygon.get_ratings(@rating.crop, @rating.polygon, @rating.climateData.data, @rating.climate, @rating.errors) if @rating.errors == []
	Polygon.aggregate_ratings(@rating.polygon.components, @rating.climate, @rating.aggregate) if @rating.errors == []
	if @rating.errors == [] then # output results
		outputHtmlFile.puts '<tr><td>' + poly + ' = </td><td>' + @rating.aggregate + '</td></tr>'
		for cmp, index in @rating.polygon.components.each_with_index do
			csv = @rating.polygon.poly_id # POLY_ID
			csv += ',' + cmp.cmp_id # CMP_ID
			csv += ',' + @rating.aggregate # POLY_RATING
			csv += ',' + @rating.polygon.cmpData[index].cmp.to_s # CMP
			csv += ',' + @rating.polygon.cmpData[index].percent.to_s # PERCENT
			begin
				csv += ',' + [@rating.climate.suitability,cmp.soil.SuitabilityClass,cmp.landscape.SuitabilityClass].max.to_s # CMP_CLASS
			rescue ArgumentError
				csv += ',' + 'NR'
			end
			csv += ',' + @rating.climate.FinalRating.to_i.to_s # CLIMATE_POINTS
			csv += ',' + @rating.climate.suitability.to_s # CLIMATE_CLASS
			csv += ',' + cmp.soil.name.province # PROVINCE
			csv += ',' + cmp.soil.name.soil_code # SOIL_CODE
			csv += ',' + cmp.soil.name.modifier # SOIL_NAME
			csv += ',' + cmp.soil.FinalSoilRating.to_s # SOIL_POINTS
			csv += ',' + cmp.soil.SuitabilityClass.to_s # SOIL_CLASS
			csv += ',' + cmp.landscape.FinalRating.to_s# LANDSCAPE_POINTS
			csv += ',' + cmp.landscape.SuitabilityClass.to_s # LANDSCAPE_CLASS
		
			outputCsvFile.puts csv
		end
	else # output error message
		outputHtmlFile.puts '<tr><td>' + poly + ' = </td><td>' + @rating.errors.join("; ") + '</td></tr>'
	end
end

# close the HTML file
outputHtmlFile.puts "</table>"
outputHtmlFile.puts "</body>"
outputHtmlFile.puts "</html>"
outputHtmlFile.close

# close the CSV file
outputCsvFile.close

puts @control['OutputHtmlFilename']
puts
puts @rating.climate.inspect
puts "Got to here".green
